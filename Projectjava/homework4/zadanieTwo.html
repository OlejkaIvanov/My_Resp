<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Бродилка</title>
</head>
<body>
  <script>
    "use strict";

  /**
  * Запускает игру.
  */
  run() {
  // Инициализируем игрока, ставим его начальное местоположение
   this.player.init(this.settings.startPositionX, this.settings.startPositionY);
    // Бесконечный цикл
    while (true) {
    // Отображаем нашу игру.
    this.render();

      // Получаем направление от игрока.
      const direction = this.getDirection();

      // Если игрок сказал что хочет выйти (набрал -1), значит выходим.
      if (direction === -1) {
      alert('До свидания.');
      return;
      }

    // Получаем следующую точку пользователя в зависимости от направления.
    const nextPoint = this.player.getNextPosition(direction);
    // Если пользователь может пройти на новую точку, то двигаем игрока.
    if (this.canPlayerMakeStep(nextPoint)) {
    this.player.move(nextPoint);
  }
  }
  },

    /**
    * Отображает игру в консоли.
    */
    render() {
    // Сюда запишем все что надо отобразить.
    let map = "";

    // Цикл перебирает все строки, которые надо отобразить.
    for (let row = 0; row < this.settings.rowsCount; row++) {
      // В каждой строке отображаем для каждой колонки (x - клетка, o - игрок).
      for (let col = 0; col < this.settings.colsCount; col++) {
        // Проверяем, если на данной позиции должен быть и игрок, отображаем игрока, если нет - клетку.
        if (this.player.y === row && this.player.x === col) {
          map += 'o ';
        } else {
          map += 'x ';
        }
      }
      // После того как отобразили всю строку делаем переход на следующую строку.
      map += '\n';
    }

    // Чистим консоль.
    console.clear();
    // Выводим все что надо отобразить в игре.
    console.log(map);
    },


  // Получаем следующую точку пользователя в зависимости от направления.
  const nextPoint = this.player.getNextPosition(direction);
  // Если пользователь может пройти на новую точку, то двигаем игрока.
  if (this.canPlayerMakeStep(nextPoint)) {
  this.player.move(nextPoint);
  }

  Здесь используются 2 новых метода, которых у нас нет, это player.getNextPosition и game.canPlayerMakeStep, также в метод player.move передается теперь nextPoint.

  Давайте разбираться.

  Как уже говорил, прежде чем сделать шаг, нам надо проверить - а может ли пользователь сходить в новую точку? И тут вопрос возникает - в какую точку-то? Вот в строке

  const nextPoint = this.player.getNextPosition(direction);

  мы как раз и получаем точку, в которой окажется пользователь, если он сделает шаг. Здесь новый метод, который надо создать в объекте player - метод getNextPosition.

  /**
  * Отдает следующую точку в которой будет находиться пользователь после движения.
  * @param {int} direction Направление движения игрока.
  * @returns {{x: int, y: int}} Следующая позиция игрока.
  */
  getNextPosition(direction) {},

  Этот метод должен будет отдать точку, в которой окажется игрок, если произойдет движение. Точка - это обычный объект в котором есть свойства x и y, например:

  { x: 2, y: 5}

  Это точка с координатами X=2, Y=5.

  Нам же эта функция getNextPosition должна возвращать следующую точку, где окажется пользователь, если он сделает шаг, алгоритм метода getNextPosition простой:

  1. Создайте переменную с объектом, не свойство объекта player, а просто переменную, например:

  const nextPosition = {};

  В этом объекте будут свойства x и y с текущей позицией игрока, то есть вам в этот пустой объект надо поместить свойства x и y равные свойствам x и y самого объекта player. У нас получится точка, в которой сейчас находится игрок (позже поменяем).

  2. Измените положение в точке nextPosition, в зависимости от направления игрока. Эту часть можно взять из метода player.move, забрать оттуда сам switch (в методе player.move он больше не понадобится), только надо его немного переделать, менять не положение самого объекта игрока, а менять точку, созданную в первом пункте.

  3. После изменения точки мы возвращаем точку nextPosition. Это как раз и будет точка, в которой окажется игрок, если мы его передвинем по направлению его движения.

  // Получаем следующую точку пользователя в зависимости от направления.
  const nextPoint = this.player.getNextPosition(direction);
  // Если пользователь может пройти на новую точку, то двигаем игрока.
  if (this.canPlayerMakeStep(nextPoint)) {
  this.player.move(nextPoint);
  }

  Итак, разобрались с первой частью. Дальше у нас идет условие, в условии мы получаем от метода game.canPlayerMakeStep правду (true), если пользователь может находиться в точке, которую мы передаем в этот метод, и ложь (false), если пользователь не может находиться в точке, которую мы передали в этот метод canPlayerMakeStep. Мы как раз с помощью этого метода будем проверять, а можем ли мы поставить пользователя в точку nextPoint, а именно в следующую точку по направлению движения пользователя. Потребуется создать метод game.canPlayerMakeStep, так как его у нас еще нет.

  У вас здесь может возникнуть вопрос, а почему мы создаем метод в объекте game, раз мы определяем может ли пользователь сходить в следующую точку? Не стоит ли переместить этот метод в объект player, раз это относится к игроку?
  Ответ нет, не стоит. Объект player не должен знать ничего об окружающем мире. В объекте player должны находиться методы непосредственно связанные только с самим игроком. Игрок у нас может сделать шаг, он может посчитать какая будет следующая точка если произойдет шаг. Но пользователь ничего не должен знать о том, какое у нас поле, всей бизнес-логикой должен заниматься объект game.

  Итак, создаем метод canPlayerMakeStep внутри объекта game:

  /**
  * Проверяет может ли пользователь перейти на точку.
  * @param {{x: int, y: int}} nextPoint Точка, которую проверяем.
  * @returns {boolean} true если пользователь может перейти в направлении, false если нет.
  */
  canPlayerMakeStep(nextPoint) {},

  Еще раз, внутри этого метода вы должны будете вернуть правду, если точка nextPoint - это точка, где пользователь может находиться и ложь, если в точке nextPoint пользователь не может находиться. Для этого нужно подумать в каких пределах может лежать эта точка.

  Ну и осталась единственный метод - player.move, он у нас уже был, но его надо переделать.

  /**
  * Двигает игрока по переданному направлению.
  * @param {{x: int, y: int}} nextPoint Следующая точка пользователя.
  */
  move(nextPoint) {},

Здесь все достаточно просто - мы методу передаем точку, куда пользователю надо переместиться, метод move должен координаты x и y у объекта player поставить в те значения, что были переданы в объекте nextPoint.
  </script>
</body>
</html>

